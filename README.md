# league-simulator-cpp
A C++ Fantasy League Simulator developed for a university project in 2019.

# Creating person files with random data.

The first step in running this simulator was creating the database files that help us extract the information for our objects during the simulation. Since the program needs a total of 140 players, it is not logical to fill the file with data manually, since for each player we need a name, age, position, years of experience, skill level, and fitness level. First, 140 random names have been extracted with the help of listofrandomnames.com, which have been entered into . txt files . Next, a method has been created in the CompeticionDeFutbol class that, when executed once, extracts the names from our names file and prints them into another one, including random data for age, years of experience, skill level, and fitness level.
For age, rand( )%20 + 17 has been used to get realistic results, and a similar equation has been used to make sense of years of experience as well.
For form and skill levels, we tried running random numbers between 0 and 99, but the league simulation gave strange results. To solve this problem, we created a mathematical function that creates a Gaussian distribution of players, centered around 50. Therefore, most players have form and skill levels around 50, and very poor players (around 10) and very good players (around 90) are rare. This has produced much more interesting data in the simulation. The exact numbers used for this equation have been obtained by trial and error.
Although the player class is the most complex, random generators have also been used for the rest of the Persona-inherited classes.

# Initializing the Simulation

To start with, we wanted to leave a very clean main ( ) method, so the final version of the program consists of three lines. From the main , our object of type CompeticionDeFutbol is created and then we call its simularCompeticion ( ) method. Within this method, we distinguish three parts, the calls to the initializations, the simulation of the days, and the printing of the information both in files and on the screen.
Initializations are done in CompeticionDeFutbol . First, the teams are generated. The constructor of each team includes the generation of its 2 scouts, sponsor, and 7 players, and the constructor of the players includes the generation of their representative, so everything is done automatically. The <vector> template has been used throughout the program. To generate the objects and link them to others, vectors of pointers have been created that point to the created objects, thus facilitating access to them and without occupying huge amounts of memory. Most of the program's operations are produced by making calls to these pointers.
Next, the 15 referees for the competition are generated. Finally, we instantiate an initial date for the competition, and proceed to generate the calendar. The creation of the calendar includes in its constructor a function that calculates the dates of our 38 rounds. In addition, the method that writes the data of the rounds to the output file calendar.txt is also included here.
Round -Robin has been used , which is frequently used in draws of this type. This algorithm generates a schedule that allows all teams to face each other, and guarantees that they do not play more than 3 consecutive home or away games. In addition, it is the algorithm used in the LFP itself. The algorithm generates and assigns 10 matches to each of our rounds, with a random referee.
Once the necessary objects have been created, the simulation can be carried out.

# Season Simulation
Within the simulateCompetition ( ) method itself, a loop is created that goes through every 10 matches of each of our 38 rounds. In each of the matches, it calls the Match:: simulateParty ( ) method.

# Match Simulation
This is probably the most important function of the program. Its constructor contains 2 teams and 1 referee. All the information about the match events is stored within its private attributes after calling the simulateMatch ( ) method.
First, for each team, the Team:: callPlayers () method is called. With this method, we introduce 5 players fit to play (without injuries or suspensions) into a vector of 5 positions, preferably taking the players in their correct field position. For the tournament, we simulate 1 goalkeeper, 1 defender, 2 midfielders and 1 forward.
Once the lineups have been drawn up, the strength of each team is calculated. First, the attacking and defensive strengths are calculated for each team. For the defensive strength, the skills and form of the goalkeeper, defender, and midfielders are added together (form has been considered to be half as important as skill, so it is multiplied by 0.5). For attack, the skills and form of the midfielders and the forward are added together. For both cases, the value of the skill and form of the midfielders has been halved since they participate in both attack and defense, and without making this change, the teams with better midfielders always came out on top.
These strength indices result in a number between 0 and 300, although since we have made a Gaussian distribution of the players, it is usually understood to be around 150.
Next, the scoring probability for each team has been calculated. First we get the difference between the home team's attack and the away team's defense, and then the difference between the away team's attack and the home team's defense. This results in numbers between -300 and 300, so 300 is added to the figure to always obtain a positive value. In addition, 40 more points are added to the home team for playing at home.
In short, we have a number between 0 and 600 for each team that indicates the probability of scoring a goal (between 40 and 640 for the home team). This number, within the program, we have called it 'difference' (because it is the differences between attacking and defensive strengths mentioned above) but it is really the 'power' of a team, its probability of scoring a goal.
For the simulation, a goal chance system has been designed, which favours strong teams in terms of winning the match, but allows weak teams to win in exceptional cases. For example, if a team has achieved a 'power' value of 200, it will have 20 chances to score a goal. If it has achieved 400, it will have 40 chances. In addition, for each chance, strong teams have a higher percentage of chances to convert into a goal. Since the 'power' values of each team normally fluctuate between 200 and 400, the probability of converting each chance into a goal fluctuates between 3 and 6%.
This method has provided some very interesting data, offering realistic results, giving a clear advantage to the strongest teams, and occasionally producing victories for the weaker teams.
Once the result has been decided, the goals are allocated to each team. If a team has scored 3 goals, these goals are distributed among its players, taking into account skill level as well as position (forwards score more goals than centres, and centres more than defenders). Forwards have been given a probability factor of 0.7, midfielders 0.5, defenders 0.3 and goalkeepers 0.01. This factor is multiplied by the player's skill level, and the probability of each goal being awarded to them is obtained. A loop is performed until each goal has been allocated to a player.
For penalties and injuries, a loop has simply been implemented that has a probability of marking a player as penalized or injured (20% probability for penalties, and 5% for injuries), and exits the loop in the event of a penalty or injury to avoid marking another one. The loop starts with the defenders and ends with the forwards, since defensive positions are more physical and have a higher probability of injury and penalty. The goalkeeper cannot be penalized or injured. Although the wording implies that a player from the same team cannot be injured and penalized in the same match, this possibility has been implemented, since without it the seventh player of each team never comes into play.
Finally, points are distributed to each team based on the result.

# Signings
The transfers have been implemented in a very basic way. Midway through the season, after matchday 19, the winter transfers take place. To do this, teams are randomly paired, exchanging a player of the same position with each other and with an economic exchange that depends on the player's skill. In addition, each player's representative takes over during the operation.
In this way, we prevent the possibility of leaving teams without enough players for each position on the field.

# File Generation
As indicated in the statement, methods have been implemented that print simulation information in . txt files . First, a calendar.txt file is generated with all the dates of the sessions. Secondly, the detailed information of each session is printed in a . txt file with the name of said session. Finally, a classification.txt file is generated with the final classification.
To access in detail the algorithms for ordering teams or players, there are comments in the program itself to clarify the procedures used.
Printing information on screen
In order to access more detailed information about the simulation in a more dynamic way, a post-simulation menu has been implemented that allows us to navigate through all the competition data. This implementation has been done within CompeticionDeFutbol.cpp and is quite extensive, so the size of this file is very high because of it.

